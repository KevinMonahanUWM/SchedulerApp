from django.shortcuts import render
from django.views import View

from TAScheduler.models import TA, Instructor, Administrator, User, Lecture, Lab
from TAScheduler.views_methods import LectureObj, LabObj, TAObj, InstructorObj, AdminObj


# Mostly temporary to get basic skeleton working
# TODO add post methods and make login screen default
# TODO fix the get methods to pass content information
# TODO make each page require correct session token to access

def determineUser(user):  # Str generated by the database
    email = user.split(": ", 1)[1]
    email_role = email.split(" -  ", 1)
    selected_user = User.objects.get(email_address=email_role[0])
    if email_role[1].lower() == "ta":
        user_object = TAObj(TA.objects.get(user=selected_user))
    elif email_role[1].lower() == "instructor":
        user_object = InstructorObj(Instructor.objects.get(user=selected_user))
    else:
        user_object = AdminObj(Administrator.objects.get(user=selected_user))
    return user_object


class Login(View):

    def get(self, request):
        return render(request, "login.html")


class Home(View):

    def get(self, request):
        return render(request, "home.html")


class CourseManagement(View):

    def get(self, request):
        return render(request, "courseManagement/course_management.html")


class CreateCourse(View):

    def get(self, request):
        return render(request, "courseManagement/create_course.html")


class DeleteCourse(View):

    def get(self, request):
        return render(request, "courseManagement/delete_course.html")


class EditCourse(View):

    def get(self, request):
        return render(request, "courseManagement/edit_course.html")


class AddInstructorToCourse(View):

    def get(self, request):
        return render(request, "courseManagement/add_instructor_to_course.html")


class AccountManagement(View):

    def get(self, request):
        return render(request, "accountManagement/account_management.html")


class CreateAccount(View):

    def get(self, request):
        return render(request, "accountManagement/create_account.html")


class DeleteAccount(View):

    def get(self, request):
        return render(request, "accountManagement/delete_account.html")


class EditAccount(View):

    def get(self, request):
        return render(request, "accountManagement/edit_account.html")


class SectionManagement(View):

    def get(self, request):
        return render(request, "sectionManagement/section_management.html")


class CreateSection(View):
    def get(self, request):
        return render(request, "sectionManagement/create_section.html")

    def post(self, request):
        section_id = request.POST.get('section_id')
        course_id = request.POST.get('course_id')
        section_type = request.POST.get('section_type')
        location = request.POST.get('location')
        meeting_time = request.POST.get('meeting_time')
        secInfo = {'section_id': section_id, 'course_id': course_id,
                   'section_type': section_type, 'location': location, 'meeting_time': meeting_time}

        adminUser = request.session["user_object"]  # ASSUMING WE'RE STORING AdminObj IN SESSION AT THE LOGIN
        try:
            # ASSUMING .createSection() WILL HANDLE ALL THE BAD INPUT.
            # WE'RE GOING TO NEED TO ADJUST ALL OUR MESSAGES TO RETURN MESSAGES NOT JUST THROW EXCEPTIONS
            # ... UNLESS MAKE CUSTOM EXCEPTIONS AND CHECK FOR THOSE HERE?
            message = adminUser.createSection(secInfo)
            # WE DON'T HAVE SUCCESS URL OR SUCCESS HTML ATM.
            return render(request, "success.html", {"message": message})
        except:
            # WE DON'T HAVE ERROR URL OR ERROR HTML ATM.
            # NEED A WAY TO RETURN AN INFORMATIVE MESSAGE FROM THE CREATESECTION METHOD
            return render(request, "error.html", {"message": message})


class DeleteSection(View):

    def get(self, request):
        return render(request, "sectionManagement/delete_section.html")


class EditSection(View):

    def get(self, request):
        return render(request, "sectionManagement/edit_section.html")


class AddUserToSection(View):

    def get(self, request):
        users = list(map(str, TA.objects.all()))
        users.extend(list(map(str, Instructor.objects.all())))
        if len(users) == 0:
            return render(request,
                          "error.html",
                          {"message": "No Users to display", "previous_url": "home/managesection"})

        return render(request, "sectionManagement/add_user_to_section.html",
                      {"users": users, "message": "Please select a user to assign"})

    def post(self, request):
        selecteduser = request.POST["user"]
        if selecteduser is None or selecteduser == '':
            users = request.POST["users"]
            return render(request,
                          "sectionManagement/add_user_to_section.html",
                          {"users": users,
                           "message": "Choose a User"})

        courses = None
        if isinstance(selecteduser, TA):
            if selecteduser.grader_status:
                courses = list(map(str, Lecture.objects.all()))
            else:
                courses = list(map(str, Lab.objects.all()))
        if isinstance(selecteduser, Instructor):
            courses = list(map(str, Lecture.objects.all()))

        if len(courses) == 0:
            return render(request,
                          "error.html",
                          {"message": "No Courses to display", "previous_url": "home/managesection"})

        chosenuser = determineUser(request.POST["user"]).getUsername()
        return render(request,
                      "sectionManagement/choose_section_add_user.html",
                      {"chosen": chosenuser, "courses": courses})


class ChooseSectionForUser(View):
    def get(self, request):
        #
        chosenuser = request.POST["chosen"]
        chosencourse = request.POST["course"]
        if chosencourse is None:
            courses = request.POST["courses"]
            return render(request,
                          "sectionManagement/choose_section_add_user.html",
                          {"chosen": chosenuser,
                           "courses": courses,
                           "message": "Choose a course"})

        user_database = User.objects.get(email_address=request.POST["username"])
        if isinstance(chosencourse, Lecture):
            chosencourse = LectureObj(chosencourse)
            if Instructor.user.objects.filter(email_address=chosenuser).exists():
                user = Instructor.objects.get(user=user_database)
                chosencourse.addInstr(user)
            elif TA.user.objects.filter(email_address=chosenuser).exists():
                user = TA.objects.get(user=user_database)
                chosencourse.addTA(user)
            else:
                return render(request, "error.html", {"message": "Could not find user",
                                                      "previous_url": "home/managesection"})

        if isinstance(chosencourse, Lab):
            chosencourse = LabObj(chosencourse)
            if TA.user.objects.filter(email_address=chosenuser).exists():
                user = TA.objects.get(user=user_database)
                chosencourse.addTA(user)
            else:
                return render(request, "error.html", {"message": "Could not find user",
                                                      "previous_url": "home/managesection"})

        return render(request, "success.html", {"message": "TA successfully added",
                                                "previous_url": "home/managesection"})


class Success(View):

    def get(self, request):
        return render(request, "success.html")


class Error(View):

    def get(self, request):
        return render(request, "success.html")
